import PDFDocument from 'pdfkit'
import { format } from 'date-fns'
import { ChartGenerator } from './ChartGenerator'
import {
  ReportConfig,
  ReportData,
  AgentReportData,
  PlatformReportData,
  TrendReportData,
} from './types'
import { createWriteStream } from 'fs'

/**
 * PDF Report Generator for MoltBeat analytics
 * Generates professional PDF reports with charts and tables
 */
export class ReportGenerator {
  private chartGenerator: ChartGenerator
  private doc!: typeof PDFDocument.prototype
  private currentY: number = 0

  constructor() {
    this.chartGenerator = new ChartGenerator(500, 300)
  }

  /**
   * Generate a report and return as Buffer
   */
  async generateReport(reportData: ReportData): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = []

      this.doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
      }) as any

      this.doc.on('data', (chunk: Buffer) => chunks.push(chunk))
      this.doc.on('end', () => resolve(Buffer.concat(chunks)))
      this.doc.on('error', reject)

      this.generateContent(reportData)
        .then(() => this.doc.end())
        .catch(reject)
    })
  }

  /**
   * Generate a report and save to file
   */
  async generateReportToFile(
    reportData: ReportData,
    filePath: string
  ): Promise<void> {
    return new Promise((resolve, reject) => {
      this.doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
      }) as any

      const stream = createWriteStream(filePath)
      this.doc.pipe(stream)

      stream.on('finish', resolve)
      stream.on('error', reject)

      this.generateContent(reportData)
        .then(() => this.doc.end())
        .catch(reject)
    })
  }

  /**
   * Generate report content based on type
   */
  private async generateContent(reportData: ReportData): Promise<void> {
    // Header
    this.addHeader(reportData.config)
    this.currentY = 150

    // Content based on report type
    switch (reportData.type) {
      case 'agent':
        await this.generateAgentReport(
          reportData.data as AgentReportData,
          reportData.config
        )
        break
      case 'platform':
        await this.generatePlatformReport(
          reportData.data as PlatformReportData,
          reportData.config
        )
        break
      case 'trend':
        await this.generateTrendReport(
          reportData.data as TrendReportData,
          reportData.config
        )
        break
    }

    // Footer
    this.addFooter(reportData.config)
  }

  /**
   * Add header to PDF
   */
  private addHeader(config: ReportConfig): void {
    // Title
    this.doc
      .fontSize(24)
      .font('Helvetica-Bold')
      .text(config.title, 50, 50, { align: 'center' })

    // Subtitle
    if (config.subtitle) {
      this.doc
        .fontSize(14)
        .font('Helvetica')
        .text(config.subtitle, 50, 85, { align: 'center' })
    }

    // Date range
    const dateStr = `${format(config.dateRange.from, 'MMM dd, yyyy')} - ${format(config.dateRange.to, 'MMM dd, yyyy')}`
    this.doc
      .fontSize(10)
      .font('Helvetica')
      .text(dateStr, 50, 115, { align: 'center' })

    // Separator line
    this.doc
      .moveTo(50, 135)
      .lineTo(545, 135)
      .stroke()
  }

  /**
   * Add footer to PDF
   */
  private addFooter(config: ReportConfig): void {
    const footerText =
      config.footer || `Generated by MoltBeat Analytics on ${format(new Date(), 'MMM dd, yyyy HH:mm')}`

    this.doc
      .fontSize(8)
      .font('Helvetica')
      .text(footerText, 50, 780, { align: 'center' })
  }

  /**
   * Generate agent performance report
   */
  private async generateAgentReport(
    data: AgentReportData,
    config: ReportConfig
  ): Promise<void> {
    // Agent Summary Section
    this.addSectionTitle('Agent Summary')
    this.addKeyValuePairs([
      ['Agent Name', data.name],
      ['Karma', data.karma.toLocaleString()],
      ['Followers', data.followers.toLocaleString()],
      ['Following', data.following.toLocaleString()],
      ['Total Posts', data.postCount.toLocaleString()],
      ['Total Comments', data.commentCount.toLocaleString()],
    ])

    this.currentY += 20

    // Metrics Chart
    if (config.includeCharts && data.metricsHistory.length > 0) {
      this.addSectionTitle('Performance Trends')

      const labels = data.metricsHistory.map((m) =>
        format(m.date, 'MMM dd')
      )
      const karmaData = data.metricsHistory.map((m) => m.karma)
      const followersData = data.metricsHistory.map((m) => m.followers)
      const engagementData = data.metricsHistory.map((m) => m.engagement)

      const chartBuffer = await this.chartGenerator.generateLineChart(labels, [
        { label: 'Karma', data: karmaData, borderColor: 'rgb(54, 162, 235)' },
        {
          label: 'Followers',
          data: followersData,
          borderColor: 'rgb(255, 99, 132)',
        },
        {
          label: 'Engagement',
          data: engagementData,
          borderColor: 'rgb(75, 192, 192)',
        },
      ])

      this.checkPageBreak(320)
      this.doc.image(chartBuffer, 50, this.currentY, { width: 500 })
      this.currentY += 320
    }

    // Top Posts Table
    if (config.includeTables && data.topPosts.length > 0) {
      this.addSectionTitle('Top Posts')
      this.addTable(
        ['Title', 'Upvotes', 'Comments', 'Engagement'],
        data.topPosts.map((p) => [
          p.title.substring(0, 50),
          p.upvotes.toString(),
          p.commentCount.toString(),
          p.engagement.toString(),
        ])
      )
    }
  }

  /**
   * Generate platform analytics report
   */
  private async generatePlatformReport(
    data: PlatformReportData,
    config: ReportConfig
  ): Promise<void> {
    // Platform Summary
    this.addSectionTitle('Platform Overview')
    this.addKeyValuePairs([
      ['Total Agents', data.totalAgents.toLocaleString()],
      ['Active Agents', data.activeAgents.toLocaleString()],
      ['Total Posts', data.totalPosts.toLocaleString()],
      ['Total Comments', data.totalComments.toLocaleString()],
      ['Average Engagement', data.avgEngagement.toFixed(2)],
    ])

    this.currentY += 20

    // Engagement Trend Chart
    if (config.includeCharts && data.engagementTrend.length > 0) {
      this.addSectionTitle('Engagement Trend')

      const labels = data.engagementTrend.map((e) => format(e.date, 'MMM dd'))
      const values = data.engagementTrend.map((e) => e.value)

      const chartBuffer = await this.chartGenerator.generateLineChart(labels, [
        {
          label: 'Engagement Score',
          data: values,
          borderColor: 'rgb(75, 192, 192)',
        },
      ])

      this.checkPageBreak(320)
      this.doc.image(chartBuffer, 50, this.currentY, { width: 500 })
      this.currentY += 320
    }

    // Top Agents Table
    if (config.includeTables && data.topAgents.length > 0) {
      this.addSectionTitle('Top Agents')
      this.addTable(
        ['Agent', 'Karma', 'Followers'],
        data.topAgents.map((a) => [
          a.name,
          a.karma.toLocaleString(),
          a.followers.toLocaleString(),
        ])
      )

      this.currentY += 20
    }

    // Top Submolts Table
    if (config.includeTables && data.topSubmolts.length > 0) {
      this.addSectionTitle('Top Submolts')
      this.addTable(
        ['Submolt', 'Posts', 'Engagement'],
        data.topSubmolts.map((s) => [
          s.name,
          s.postCount.toLocaleString(),
          s.engagement.toFixed(2),
        ])
      )
    }
  }

  /**
   * Generate trend analysis report
   */
  private async generateTrendReport(
    data: TrendReportData,
    config: ReportConfig
  ): Promise<void> {
    // Trending Topics
    if (config.includeTables && data.trendingTopics.length > 0) {
      this.addSectionTitle(`Trending Topics (${data.period})`)
      this.addTable(
        ['Topic', 'Mentions', 'Sentiment', 'Trend'],
        data.trendingTopics.map((t) => [
          t.topic,
          t.mentions.toLocaleString(),
          t.sentiment.toFixed(2),
          t.trend,
        ])
      )

      this.currentY += 20
    }

    // Sentiment Analysis Chart
    if (config.includeCharts) {
      this.addSectionTitle('Sentiment Distribution')

      const chartBuffer = await this.chartGenerator.generateDoughnutChart(
        ['Positive', 'Neutral', 'Negative'],
        [
          data.sentimentAnalysis.positive,
          data.sentimentAnalysis.neutral,
          data.sentimentAnalysis.negative,
        ],
        'Sentiment Analysis'
      )

      this.checkPageBreak(320)
      this.doc.image(chartBuffer, 50, this.currentY, { width: 500 })
      this.currentY += 320
    }

    // Viral Content
    if (config.includeTables && data.viralContent.length > 0) {
      this.addSectionTitle('Viral Content')
      this.addTable(
        ['Title', 'Author', 'Viral Score', 'Engagement'],
        data.viralContent.map((v) => [
          v.title.substring(0, 40),
          v.author,
          v.viralScore.toFixed(2),
          v.engagement.toString(),
        ])
      )
    }
  }

  /**
   * Add section title
   */
  private addSectionTitle(title: string): void {
    this.checkPageBreak(40)
    this.doc
      .fontSize(16)
      .font('Helvetica-Bold')
      .text(title, 50, this.currentY)
    this.currentY += 30
  }

  /**
   * Add key-value pairs
   */
  private addKeyValuePairs(pairs: Array<[string, string]>): void {
    pairs.forEach(([key, value]) => {
      this.checkPageBreak(20)
      this.doc
        .fontSize(11)
        .font('Helvetica-Bold')
        .text(`${key}: `, 50, this.currentY, { continued: true })
        .font('Helvetica')
        .text(value)
      this.currentY += 20
    })
  }

  /**
   * Add table
   */
  private addTable(headers: string[], rows: string[][]): void {
    const colWidth = 500 / headers.length
    const rowHeight = 25

    // Check if table fits on current page
    const tableHeight = (rows.length + 1) * rowHeight + 10
    this.checkPageBreak(tableHeight)

    // Headers
    this.doc.fontSize(10).font('Helvetica-Bold')
    headers.forEach((header, i) => {
      this.doc.text(header, 50 + i * colWidth, this.currentY, {
        width: colWidth - 10,
        align: 'left',
      })
    })
    this.currentY += rowHeight

    // Header separator
    this.doc
      .moveTo(50, this.currentY - 5)
      .lineTo(550, this.currentY - 5)
      .stroke()

    // Rows
    this.doc.font('Helvetica')
    rows.forEach((row) => {
      row.forEach((cell, i) => {
        this.doc.text(cell, 50 + i * colWidth, this.currentY, {
          width: colWidth - 10,
          align: 'left',
        })
      })
      this.currentY += rowHeight
    })

    this.currentY += 10
  }

  /**
   * Check if we need a page break
   */
  private checkPageBreak(requiredSpace: number): void {
    if (this.currentY + requiredSpace > 750) {
      this.doc.addPage()
      this.currentY = 50
    }
  }
}
